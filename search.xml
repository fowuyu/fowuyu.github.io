<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包的理解]]></title>
    <url>%2F2018%2F10%2F20%2F%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[闭包，这是函数式编程的一个典型用法，很多人对其定义深感困惑，即便看懂例子，让其给别人介绍什么是闭包，他依然无法清晰准确的回答出什么是闭包。其实闭包很简单，之所以让人感到困惑，是因为大家不知道闭包底层是如何实现的，一旦大家理解如何实现闭包，则问题迎刃而解。首先我们看一下Golang的一个闭包例子： 12345678910111213141516package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int&#123; num++ return num &#125;&#125;func main() &#123; rtFunc := clourse(2) fmt.Println(rtFunc()) //3 fmt.Println(rtFunc()) //4&#125; 再看如下调用后所得结果： 1234567891011121314151617181920package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int &#123; num++ return num &#125;&#125;func main() &#123; rtFuncOne := clourse(2) rtFruncTwo := clourse(7) fmt.Println(rtFuncOne()) //答案 3 fmt.Println(rtFuncOne()) //答案 4 fmt.Println(rtFuncTwo()) //答案 8 fmt.Println(rtFuncTwo()) //答案 9&#125; 如果能够快速回答出上述代码的输出，并理解原因，则无需阅读下面的内容。如果还是不太理解答案，则下文将带你彻底弄懂闭包。 闭包的定义较为晦涩，我个人的理解是调用一个函数A，这个A函数返回一个函数B，返回的函数B中还包括了函数A的上下文环境。这样描述还是比较难以理解。在先讲闭包前，看一个行为和闭包一样的代码例子： 123456789101112131415161718package mainimport "fmt"type clourse struct &#123; num int&#125;func (cs *clourse) add() int &#123; cs.num++ return cs.num&#125;func main() &#123; test := clourse&#123;2&#125; fmt.Println(test.add()) //答案 3 fmt.Println(test.add()) //答案 4&#125; 如果看到这里，你恍然大悟了，那么你便懂了什么是闭包，如果还是没懂，没关系。我来讲解一下闭包的底层实现。 在第一个闭包的例子中，你可以这样理解，函数clourse返回的不是一个函数，而是一个结构 ,这个结构包含一个上下文num,还包括一个自增函数 ，自增函数每次都是在num的基础上进行过程调用。上述闭包达到的效果就是和第三个小例子一样，而实际上，golang在底层也是如此实现的。看到这里，你如果深入理解闭包的返回值，其实这不就是对应java中的class吗？一个class,封装了数据和对数据的操作，并且这份数据只属于此class，多次调用一个class的实例，将带来多次副作用。进一步的，其实在C语言中在Struct中包含一个上下文，一个函数指针，也能实现上述效果，其实上述结构描述的都是一种封装概念，将数据和对数据的操作封装起来供开发者调用。只不过在函数式编程里面，为了达到上述效果，发明了一个闭包的概念。殊途而同归，深入理解这些概念，你会发现编程语言特性才是最重要的，如果不能深入理解编程语言特性，不管你学多少种编程语言，还是不能达到融会贯通的地步。]]></content>
      <categories>
        <category>Function Programming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的值语义与引用语义]]></title>
    <url>%2F2018%2F10%2F16%2FGo%E8%AF%AD%E8%A8%80%E7%9A%84%E5%80%BC%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[​ 任何一门语言，如果其有指针概念，则需要了解这门语言是否拥有引用语义，当然你可以说任何引用语义都是值语义（正确的废话）。之所以这个内容需要深入理解，因为它涉及到一个重要的内容，那就是比较 ，编程语言的三大结构，都需要依赖比较功能，而比较就需要我们理解比较的到底是变量的值，还是变量指向的值。 12345func main&#123; a := "yichen" b := "yichen" fmt.Print(a == b) //true 可以看出string是值语义&#125; 123456func main&#123; a := [3]&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,2,3&#125;,&#123;1,3,3&#125; 可以看出数组居然也是值语义&#125; 123456func main&#123; a := []&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,3,3&#125;,&#123;1,3,3&#125; 可以看出slice是引用语义&#125; 12345678910type Person struct&#123; age int name string&#125;func main() &#123; yichen := Person&#123;21,"yichen"&#125; pengfan := Person&#123;21,"yichen"&#125; fmt.Println(yichen == pengfan) //true 不可思议的是struct也是值语义&#125; 1234567891011type Person struct&#123; age int name string&#125;func main() &#123; a := Person&#123;21,"yichen"&#125; b := &amp;a c := &amp;a fmt.Println(b == c) //true 指针也是值语义&#125; 总结值语义基本类型，如byte、int、bool、float32、float64和string等;复合类型，如数组(array)、结构体(struct)和指针(pointer)等。 引用语义slice,map,list,heap,ring,channels]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Home]]></title>
    <url>%2F2018%2F10%2F16%2FHome%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到我的博客，此博客是为了记录个人学习，生活中的一些随笔，如有帮助，欢迎点击文章底部的打赏按钮，比心。]]></content>
  </entry>
</search>
