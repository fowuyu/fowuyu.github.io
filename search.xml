<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TCP中seq和ack详解]]></title>
    <url>%2F2019%2F05%2F07%2FTCP%E7%9A%84seq%E5%92%8Cack%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[​ seq和ack号存在于TCP报文段的首部中，seq是序号，ack是确认号，大小均为4字节（注意与大写的ACK不同，ACK是6个控制位之一，大小只有一位， 仅当 ACK=1 时ack字段才有效。建立 TCP 连接后，所有报文段都必须把 ACK 字段置为 1。 seq：占 4 字节，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号。ack：占 4 字节，期望收到对方下个报文段的第一个数据字节的序号。 1、三次握手过程中seq和ack的值：一个TCP连接的建立是通过三次握手来实现的 1.(A) –&gt; [SYN] –&gt; (B) ​ 假如服务器B和客户机A通讯. 当A要和B通信时，A首先向B发一个SYN (Synchronize) 标记的包，告诉B请求建立连接.注意: 一个 SYN包就是仅SYN标记设为1的TCP包(参见TCP包头Resources). 认识到这点很重要，只有当B受到A发来的SYN包，才可建立连接，除此之外别无他法。因此，如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能主动连接外部任何主机，除非不是TCP协议。 2.(A) &lt;– [SYN/ACK] &lt;–(B)​ 接着，B收到后会发一个对SYN包的确认包(SYN/ACK)回去，表示对第一个SYN包的确认，并继续握手操作. 3.(A) –&gt; [ACK] –&gt; (B) A收到SYN/ACK 包,A发一个确认包(ACK)，通知B连接已建立。至此，三次握手完成，一个TCP连接完成 Note: ACK包就是仅ACK 标记设为1的TCP包. 需要注意的是当三此握手完成、连接建立以后，TCP连接的每个包都会设置ACK位握手阶段： 序号 方向 seq ack SYN ACK 1 A-&gt;B 10000 0 1 0 2 B-&gt;A 20000 10000+1=10001 1 1 3 A-&gt;B 10001 20000+1=20001 0 1 解释：1：A向B发起连接请求，以一个随机数初始化A的seq,这里假设为10000，此时ACK＝0 2：B收到A的连接请求后，也以一个随机数初始化B的seq，这里假设为20000，意思是：你的请求我已收到，我这方的数据流就从这个数开始。B的ACK是A的seq加1，即10000＋1＝10001 3：A收到B的回复后，它的seq是它的上个请求的seq加1，即10000＋1＝10001，意思也是：你的回复我收到了，我这方的数据流就从这个数开始。A此时的ACK是B的seq加1，即20000+1=20001 2、数据传输过程中seq和ack的值： 序号 方向 seq ack size 23 A-&gt;B 40000 70000 1514 24 B-&gt;A 70000 40000+1514-54+1=41461 54 25 A-&gt;B 41461 70000+54-54+1=70001 1514 26 B-&gt;A 70001 41460+1514-54+1=42921 54 解释：23:B接收到A发来的seq=40000,ack=70000,size=1514的数据包 24:于是B向A也发一个数据包，告诉A，你的上个包我收到了。A的seq就以它收到的数据包的ack填充，ack是它收到的数据包的seq加上数据包的大小(不包括：以太网协议头=14字节，IP头=20字节，TCP头=20字节)，以证实B发过来的数据全收到了。 25:A在收到B发过来的ack为41460的数据包时，一看到41460，正好是它的上个数据包的seq加上包的大小，就明白，上次发送的数据包已安全到达。于是它再发一个数据包给B。这个正在发送的数据包的seq也以它收到的数据包的ack填充，ack 就以它收到的数据包的seq(70000)加上包的size(54)填充,即ack=70000+54-54(全是头长，没数据项)。]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>seq ack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++移动语义与右值引用]]></title>
    <url>%2F2019%2F04%2F29%2FC-%E7%A7%BB%E5%8A%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[​ C++的11标准与0x版本最大的差别在于移动语义以及为了适配移动语义所带来的一系列技术，包括值理论，新的智能指针等技术。本文主要对C++的11标准中的std::move()函数进行介绍。 ​ 在进行介绍std::move()函数之前，读者需要对C++的值理论有一定的理解，特别是右值引用的理解。std::move()函数的源码如下： 12345template&lt;typename T&gt;decltype(auto) move(T&amp;&amp; param)&#123; using ReturnType = remove_reference_t&lt;T&gt;&amp;&amp; //去掉T中的所有引用，得到其原始类型。 return static_cast&lt;ReturnType&gt;(param); //使用static_cast使用param生成右值&#125; ​ 实际上，std :: move执行的关键步骤是将其参数转换为rvalue， 它指示编译器有资格移动对象，但其函数本身不移动任何东西，编译器需要调用移动构造函数才有能力移动对象的资源。在详细介绍std::move()函数带来的移动语义之前，本文先对右值引用进行详细介绍： ​ 右值引用和左值引用一样，本质上都是对指针的封装，右值引用只能使用右值（包括xvalue和prvalue）进行初始化，不能通过左值进行初始化，但是右值引用与左值引用不同的是，可以进行重绑定操作。在进行重绑定操作时，传递的是值而非引用，具体而言： 123456int &amp;&amp;a = 0;//rightint &amp;&amp;b = a;//wrong,a is lvalueint cc = 5;a = cc;++a;std::cout&lt;&lt;a&lt;&lt;" "&lt;&lt;cc&lt;&lt;std::endl; // 6 5 ​ 上述代码使用prvalue对右值引用进行初始化可以成功，但是用左值对其进行初始化缺失败，进行重绑定后，对a进行修改不影响cc本身的值，这是因为重绑定只进行了值的的传递而非引用的传递，如下代码使用xvalue对右值引用进行初始化，这也是常用的操作，： 12345678int bb = 1;int&amp;&amp; dd = std::move(bb);//std::move(bb)返回的是一个xvalue，dd++;cout &lt;&lt; bb&lt;&lt;" "&lt;&lt;dd &lt;&lt; endl; //2 2int cc = 9;dd = cc;dd++;cout &lt;&lt; bb &lt;&lt;" "&lt;&lt; cc &lt;&lt;" "&lt;&lt; dd&lt;&lt;std::endl;//10 9 10 ​ 上述代码中，cc的值不会被修改，但是bb的值被修改了，这是因为右值引用dd中的指针指向了bb，因而对dd指向任何修改操作都将直接修改bb的值（右值引用重载了基本操作，比如dd++，实际上是对dd中的指针指向的内存进行操作而不是对指针进行操作）。而一旦初始化后，进行重绑定操作的时候，一律是将其他的值拷贝到右值引用指针指向的地址中，而不会修改指针指向。实际上int&amp;&amp; 等于int* const，也就是说指针指向不能改，但是指针指向的地址内容是可以进行修改。如下代码体现了右值引用的指针本质： 1234567891011121314#include &lt;iostream&gt;using namespace std;void foo(int&amp;&amp; a)&#123; std::cout&lt;&lt;&amp;a&lt;&lt;std::endl; //1 a = 4;&#125;;int main()&#123; int a = 3; cout&lt;&lt;&amp;a&lt;&lt;endl; //2 foo(std::move(a));//std::move(a)将返回一个xvalue,然后使用其对int&amp;&amp; a进行初始化，此时foo的参数a中的指针已经指向main函数中变量a的地址，因此在foo中对a的值进行修改，会同步修改main函数中的a值。 cout&lt;&lt;a&lt;&lt;endl; return 0;&#125; ​ 当然，1和2输出的地址是一样的，这也验证了我们对右值引用的理解是正确的。下文将开始详细介绍右值引用带来的移动语义以及实现移动语义的移动构造函数（此处先忽视不谈移动赋值操作）以及编译器的一些优化行为（RVO和NRVO技术）。 ​ 在没有移动构造函数以前，C++实现移动语义是非常笨拙的，具体而言，如果在一个函数内部需要返回一个函数内新建的对象时，C++先调用其拷贝构造函数生成对象的一份拷贝，然后通过这份拷贝再调用拷贝构造函数生成一个新的对象，然后将原本的对象析构掉。当需要返回的对象拥有数量可观的属性和资源时，拷贝操作将耗费大量的CPU和内存，C++标准委员会的人觉得这样子做太傻逼，直接将函数内部的对象所拥有的资源全部转移到新的对象里不就可以节省一次拷贝，一次析构的操作了吗？说干就干，C++标准委员会的人就开始想办法，不管想出啥办法，已有的标准必须尽可能的保持不变，因为如果不向后兼容，那么新标准将分裂整个社区，使得C++举步维艰。不得不说C++标准委员会的那群大佬们很擅长打补丁，虽然是马后炮，但是C++标准变成现在这样，标准委员会难辞其咎。每个新标准都在之前的基础上打补丁，然后为了兼容，又变出很多膈应人的技术出来。废话少说，回到之前那个问题，该如何实现直接移动操作而不改变原有的标准呢？C++标准委员会的人想到了增加一种构造函数，以前有默认构造，使用参数构造，拷贝构造，那么就增加一种移动构造函数吧！使用移动构造函数来实现移动语义，问题来了，该怎么定义移动构造函数呢？它的参数应该是什么样子呢？进行符号决议的时候，该怎么判断该使用移动构造而不是使用拷贝构造呢？这就必须要求C++标准委员会移动构造函数一个特别的参数，如果换成是我来想，我就会使用一个非常特别的函数签名，一旦想要实现移动语义的时候，就手动调用此特殊函数实现对象资源的所有权转移，这是简单的重载操作。但是C++标准可不能这么简单粗暴，必须去掉手动两字才行，得自动。为此C++标准委员会那帮人想出了右值引用这个概念，然后引出了新的值分类，由以前的两种值类别变成两大类，三种具体小类，在我另外一篇C++值理论中详细介绍了。 ​ C++标准委员会的大佬们使用右值引用作为移动构造函数的参数，来实现直接移动对象资源的目的。问题来了，用纯右值初始化右值引用很简单方便，但是一般操作都是针对泛左值（gvalue）进行移动的，这就需要一种能够将左值变成右值的方法了，也就是std::move()方法所需要干的事情了。有了这两个方法，就实现了真正的移动语义，通过std::move()将一个左值转换成右值，然后通过右值引用对其进行初始化，在选择构造函数时，如果用户自定义的类有移动构造函数，则其将被调用，用以实现资源的所有权的转移操作。如下代码展示了移动语义： 12345678910111213141516171819202122232425262728293031323334//代码一#include &lt;iostream&gt;using namespace std;class Te &#123;public: Te(int a) :a(a) &#123; cout &lt;&lt; "default" &lt;&lt; endl; &#125; Te(const Te&amp; te) :a(te.a) &#123; cout &lt;&lt; "copy constructor" &lt;&lt; endl; &#125; Te(Te&amp;&amp; te) :a(te.a) &#123; cout &lt;&lt; "move constructor" &lt;&lt; endl; &#125; ~Te() &#123; std::cout &lt;&lt; "destructor" &lt;&lt; std::endl; &#125; int a;&#125;;Te foo() &#123; Te te(3); std::cout &lt;&lt; &amp;te &lt;&lt; std::endl; return std::move(te); //将te转换成prvalue,然后使用右值引用以调用移动构造函数实验移动语义&#125;;int main()&#123; Te t = foo(); std::cout &lt;&lt; &amp;t &lt;&lt; std::endl; return 0;&#125;output:default0x7fffffffe89cmove constructordestructormove constructordestructor0x7fffffffe8c8destructor ​ 上述代码使用g++编译器，并且需要开启“-fno-elide-constructors”编译选项，否则输出结果如下： 1234567891011121314151617181920212223242526272829303132//代码二using namespace std;class Te&#123;public: Te(int a):a(a)&#123;cout&lt;&lt;"default"&lt;&lt;endl;&#125; Te(const Te&amp; te):a(te.a)&#123;cout&lt;&lt;"copy constructor"&lt;&lt;endl;&#125; Te(Te&amp;&amp; te):a(te.a)&#123;cout&lt;&lt;"move constructor"&lt;&lt;endl;&#125; ~Te() &#123; std::cout &lt;&lt; "destructor" &lt;&lt; std::endl; &#125;private: int a;&#125;;Te foo()&#123; Te te; std::cout&lt;&lt;&amp;te&lt;&lt;endl;//1 return std::move(te);&#125;;int main()&#123; Te t = foo(); std::cout&lt;&lt;&amp;t&lt;&lt;std::endl;//2 return 0;&#125;output:defaultmove constructordestructor0x7fffffffe8cc0x7fffffffe8dcdestructor ​ 在解释二者区别之前，请看如下代码： 123456789101112131415161718192021222324252627282930//代码三using namespace std;class Te&#123;public: Te(int a):a(a)&#123;cout&lt;&lt;"default"&lt;&lt;endl;&#125; Te(const Te&amp; te):a(te.a)&#123;cout&lt;&lt;"copy constructor"&lt;&lt;endl;&#125; Te(Te&amp;&amp; te):a(te.a)&#123;cout&lt;&lt;"move constructor"&lt;&lt;endl;&#125; ~Te() &#123; std::cout &lt;&lt; "destructor" &lt;&lt; std::endl; &#125;private: int a;&#125;;Te foo()&#123; Te te; std::cout&lt;&lt;&amp;te&lt;&lt;endl;//1 return te;&#125;;int main()&#123; Te t = foo(); std::cout&lt;&lt;&amp;t&lt;&lt;std::endl;//2 return 0;&#125;output:default0x7fffffffe8cc0x7fffffffe8ccdestructor ​ 上述代码关闭了”-fno-elide-constructors”编译选项，否则那又是另外一回事了。上述代码中编译器发现你就是想实现移动语义嘛？你函数内的对象在函数结束后反正都要被析构，我就直接把它给你好了，不析构它，这样一来移动操作都省了，编译器只需要改变一下栈顶指针就能完成此操作。这就是真正的黑科技，这个技术叫RVO，更具体的此处应该叫NRVO，相关技术请参照其他文献进行理解。回过头去看代码一和代码二，更能理解std::move()的作用了，看了代码二和代码三，就能体会到编译器的优化能力了，似乎看起来编译器的优化能力比移动语义还要强，但是事实并非如此，因为编译器在某些时候很难判断是否能够采用RVO技术，因此使用移动语义会更普适一些。但是有些时候使用移动语义又差于编译器优化。 ​ 本文之所以要对RVO技术和NRVO技术进行简单介绍，是因为如果你不关闭“-fno-elide-constructors”选项，会很容易被编译器的优化行为误导对移动语义的理解。最后总结一下：C++的新标准为了实现移动语义，从而发明了右值引用这个概念，进一步的带来了值分类理论的更新，而因为常见操作都是需要对左值实现移动操作，因此C++创造了std::move()方法实现左值到右值的转变，确切的说是lvalue到xvalue的转变。 对于右值引用，需要注意其初始化和重绑定的原理，否则很容易导致两次释放同一对象。 ​]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>std::move()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++为什么函数压栈要从右到左]]></title>
    <url>%2F2019%2F01%2F11%2FCC%2B%2B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E5%8E%8B%E6%A0%88%E8%A6%81%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%2F</url>
    <content type="text"><![CDATA[​ 要理解这个问题，首先要理解调用函数时候的栈的变化细节，如果理解ebp,esp的变化过程，则可以进行下一步讨论，否则需要先去弄懂函数栈的调用细节。可参考深入理解计算机系统一书的介绍。闲话少叙，如果不需要支持可变参数，则函数参数的压栈顺序是无所谓的。之所以参数压栈顺序是从右往左，是因为C/C++规定变参函数的第一个参数可以用来确定后续参数的个数。这句话告诉我们，被调用函数要去获取参数值的时候，也就是ebp往高地址方向移动时，到底该移动几个字节去取参数，从右往左压的话，ebp+4是返回地址，ebp+8就是最左边参数，通过这个参数可以获取后续参数个数以及类型，也就是知道了所有参数的个数。反过来如果从左往右压，被调用函数在函数内部去获取参数值的时候，也就是ebp往高地址方向移动时，即便ebp+8也无法知道后续参数个数。因此这就是函数参数压栈顺序从右到左的原因所在。那有人就想问，能否从左往右压呢？可以的，只要你牺牲一个寄存器用来记录参数个数即可，事实上现在有的CPU就这么干了。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++中const以及static的总结]]></title>
    <url>%2F2019%2F01%2F10%2FC%2B%2B%E4%B8%ADconst%E4%BB%A5%E5%8F%8Astatic%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[​ c++的const以及static非常容易弄混，到底什么是const语义，什么是static语义，以及const和指针的搭配还有两种区别，因此给我们带来了很多麻烦。本文试图将const和static的异同进行一个总结。 ​ 以下内容针对类中变量以及函数内局部变量而言：const修饰非指针变量时候，是具有生命周期的，出了变量范围，则变量所占用的内存空间被回收，而static所修饰的变量在最终编译链接后保存在静态区域，它不依赖于对象而存在，可以直接通过类名+变量名直接调用。const依赖于对象，每个对象所拥有的const变量值不一样。这就带来一个问题，const修饰的变量需要列表初始化而不能再构造函数内赋值，原因在于当运行到类的构造函数内部时，c++规定const成员和引用成员必须在初始化列表中初始化，而不能在构造函数体内再被赋值，所以const修饰的类变量必须使用列表初始化。那const修饰的类变量是否可以申明时候即赋值呢？也就是如下代码正确吗？ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class Person&#123;public: explicit Person(string name,int age):_name(name),_age(age)&#123; cout &lt;&lt; name &lt;&lt; " is: "&lt;&lt; _age &lt;&lt; endl; &#125; virtual ~Person()&#123;&#125;private: string _name; const int _age = 7;&#125;;int main(void)&#123; Person yichen("yichen",24); // yichen is 7 return 0;&#125; 上述代码可以正常运行，但是这是一个c++11的一个拓展，并不一定在所有编译器上都能运行成功。为了保证兼容性，我们写代码时候就不要对const变量赋默认值，而是统一放到构造函数列表初始化中完成。正确范式如下： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;class Person&#123;public: explicit Person(string name,int age):_name(name),_age(age)&#123; cout &lt;&lt; name &lt;&lt; " is: "&lt;&lt; _age &lt;&lt; endl; &#125; virtual ~Person()&#123;&#125;private: string _name; const int _age;&#125;;int main(void)&#123; Person yichen("yichen",24); //output: yichen is 24; return 0;&#125; 而对于static修饰变量，就更为复杂了。上文说过static修饰的类内变量是所有对象共享的，不依赖于对象即可存在，因此static修饰的变量肯定不能用列表初始化，也不能再构造函数内赋值。那么可以在声明static变量时就赋初始值吗？答案是不可以，c++规定，非const static变量一律不能在类内初始化。也就是说如下代码是错误的； 1234private:string _name;const int _age;static double _tall = 175; //error!!! 那么static修饰的变量该如何初始化呢？c++规定要在类外部初始化。也就是要写成如下代码： 12345678910111213141516171819class Person&#123;public: explicit Person(string name,int age):_name(name),_age(age)&#123; cout &lt;&lt; name &lt;&lt; " is: "&lt;&lt; _age &lt;&lt; endl; cout &lt;&lt; "tall is: "&lt;&lt; _tall &lt;&lt; endl; &#125; virtual ~Person()&#123;&#125;private: string _name; const int _age = 7; static int _tall;&#125;;int Person::_tall = 175;int main(void)&#123; Person yichen("yichen",24);//output: yichen is: 24 tall is: 175 return 0;&#125; .这表明static修饰的变量： 1、初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆 2、初始化时不加该成员的访问权限控制符private、public等 3、初始化时使用作用域运算符来表明它所属的类，因此，静态数据成员是类的成员而不是对象的成员。 那么对于const static修饰变量以及static const修饰的变量该如何初始化呢,这两个修饰符顺序无所谓，语义一致？c++规定：const static和static const修饰的变量既可以在类内部声明处初始化，也可以在类外部赋值初始化。如果在类外部初始化，则修饰符const 不能省略，static和访问权限控制符可以省略。切记，const static不能再构造函数内赋值也不能使用列表初始化，因为它修饰的变量不属于对象，而是属于类的。 还需要注意的是static修饰的函数只能访问static数据，不能访问非static数据，这很容易理解。 const int a和int const a的区别就不再啰嗦了。前者是a中内容不可变，后者是a指向的地址不可变。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ 析构函数与delete的区别于联系]]></title>
    <url>%2F2019%2F01%2F07%2FC%2B%2B%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8Edelete%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[​ delete必须和new成对出现，delete一个指针可以视为两件事：1.调用析构函数；2.free指针所指向对象的内存空间。 ​ 即便一个类或者struct没有析构函数，delete依然可以正确释放类对象所用内存空间，但是不能正确释放类持有的其他文件句柄或者系统资源。 ​ delete调用析构函数是充分非必要操作！！！]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点数的二进制表示]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[首先看一道题： 12345678910#include &lt;stdio.h&gt;void main(void)&#123; int num=9; /* num是整型变量，设为9 */ float* pFloat=&amp;num; /* pFloat表示num的内存地址，但是设为浮点数 */ printf("num的值为：%d\n",num); /* 显示num的整型值 */ printf("*pFloat的值为：%f\n",*pFloat); /* 显示num的浮点值 */ *pFloat=9.0; /* 将num的值改为浮点数 */ printf("num的值为：%d\n",num); /* 显示num的整型值 */ printf("*pFloat的值为：%f\n",*pFloat); /* 显示num的浮点值 */&#125; 结果如下： 1234num的值为：9*pFloat的值为：0.000000num的值为：1091567616*pFloat的值为：9.000000 在讨论浮点数之前，先看一下整数在计算机内部是怎样表示的。 int num=9; 上面这条命令，声明了一个整数变量，类型为int，值为9（二进制写法为1001）。普通的32位计算机，用4个字节表示int变量，所以9就被保存为00000000 00000000 00000000 00001001，写成16进制就是0x00000009。 那么，我们的问题就简化成：为什么0x00000009还原成浮点数，就成了0.000000? 根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式： $$V = (-1)^8 M 2^E$$ （1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 （2）M表示有效数字，大于等于1，小于2。 ​ （3）2^E表示指数位。 举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。 十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。 IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。 IEEE 754对有效数字M和指数E，还有一些特别规定。 ​ 前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。 至于指数E，情况就比较复杂。首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。 比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。 然后，指数E还可以再分成三种情况： （1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。 （2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 （3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。 回顾好了，关于浮点数的表示规则，就说到这里。 下面，让我们回到一开始的问题：为什么0x00000009还原成浮点数，就成了0.000000？ 首先，将0x00000009拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M=000 0000 0000 0000 0000 1001。 由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成： V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146) 显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。 再看例题的第二部分。 请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？ 首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。 那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。 所以，写成二进制形式，应该是s+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个32位的二进制数，还原成十进制，正是1091567616。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ explicit的含义和用法]]></title>
    <url>%2F2019%2F01%2F03%2FC%2B%2B%20explicit%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[​ explicit用来修饰构造函数，表明此构造函数是需要显示调用的，不能被隐式调用，之所以会出现隐式调用，是因为我们的赋值构造函数容易被隐式的用来构造实例，例子如下： 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;class Person&#123; int _age; explicit Person(int age)&#123; _age = age; &#125; Person(const Person&amp; p)&#123; this-&gt;_age = p._age; &#125; Person&amp; operator=(const Person&amp; p)&#123; assert *this != p; this-&gt;_age = p._age; return *this; &#125;&#125;int main(void)&#123; Person a(23); // success Person *b = new Person(43); // success Person c = 4; //去掉explicit 就 success&#125; 上述代码能够编译执行，但是很明显Person c = 4代码不符合直觉，但是由于赋值构造函数的作用下，右边的4首先会被解释成Person(4)，然后被赋值给c，要避免这种反直觉的代码，我们可以用explicit修饰构造函数，使得此构造函数不能被默认调用，这样一来4就不能被解释成Person(4)。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RTTI技术]]></title>
    <url>%2F2019%2F01%2F03%2F%E5%B0%9D%E8%AF%95%E4%BB%8B%E7%BB%8DC%2B%2B%E4%B8%ADRTTI%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[​ 首先介绍一下说明是RTTI，所谓RTTI即是Runtime Type Identification（运行时类型识别），那这个技术有什么用呢？一种技术被发明都是用来解决某种问题，当然这种技术可能带来某些副作用，用不用就取决于你是否有能力控制使用新技术带来的副作用。我们知道在写代码时，会用到很多设计模式，通常为了最大程度的提供灵活性，会将很多方法中的形参写成一个基类的引用或者指针，这样将来使用者传参时，传递这个基类或者其子类都无需我们改变方法签名。但是这也带来了一个问题，由于我不知道使用者将来会传递什么子类进来，而我可能需要针对不同子类做不同操作，这时候我就想在代码里判断方法使用者传递进来的子类类型，这时候该怎么办呢？这就是RTTI技术尝试解决的问题，RTTI需要提供在运行时对类型进行识别的能力以供程序员在运行时对类型进行判定，当然需要引起注意的是C++的RTTI技术能力有限，和Java比那是天差地别，之所以会这样是因为C++为了性能不得不牺牲些特性，而RTTI对性能还是有些影响的。 ​ 要想理解清楚RTTI技术，首先得比较清楚的明白C++的多态实现机制，得对C++对象内存布局有比较好的了解，因为没有多态就无需RTTI技术。C++语言给使用者提供了两个工具来进行运行时类型识别，第一个是typeid,另一个是dynamic_cast,二者有区别有相似。首先我们来介绍typeid，要使用typeid，首先需要引入头文件#include,typeid方法需要传递一个需要判断类型的参数，这个参数可以是一个基本类型包括指针类型，也可以是类对象，甚至可以是一个value，typeid返回的是一个type_info对象，调用type_info对象的name()方法就能获取前述需要判断类型的参数的全限定名字。例子如下： 1234567891011121314151617181920212223242526272829/*例子1*/#include&lt;iostream&gt;#include&lt;typeinfo&gt;#include&lt;vector&gt;using namespace std;class X&#123;&#125;;class XX : public X&#123; &#125;;int main(void)&#123; vector&lt;int&gt; iarrays; iarrays.push_back(3); X x; XX xx; x = xx; X *xpointer = new XX(); cout &lt;&lt; typeid(iarrays).name() &lt;&lt;endl; //输出St6vectorIiSaIiEE 1 cout &lt;&lt; typeid(4).name() &lt;&lt;endl; //输出 i 表示int 2 cout &lt;&lt; typeid(x).name() &lt;&lt;endl; //输出 1X 3 cout &lt;&lt; typeid(xx).name() &lt;&lt;endl;//输出 2XX 4 cout &lt;&lt; typeid(xpointer).name() &lt;&lt;endl;//输出P1X 5 cout &lt;&lt; typeid(*xpointer).name() &lt;&lt;endl;//输出1X 6 return 0;&#125; 这里比较困惑的是输出5和输出6，先不着急解释原因，再看一个例子： 123456789101112131415161718192021/*例子2*/#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namespace std;class X&#123; virtual void myfunc(void)&#123; std::cout&lt;&lt; "X" &lt;&lt;endl; &#125;;&#125;;class XX : public X&#123; void myfunc(void)&#123; std::cout&lt;&lt;"XX"&lt;&lt;endl; &#125;&#125;;int main(void)&#123; X *xpointer = new XX(); cout &lt;&lt; typeid(xpointer).name() &lt;&lt;endl;//输出P1X 7 cout &lt;&lt; typeid(*xpointer).name() &lt;&lt;endl;//输出2XX 8 return 0;&#125; ​ 例子1和例子2中，区别在于例子2的X类有虚函数，为什么有虚函数后typeid输出基类指针的解引用就能正确输出指针指向的对象的类型呢？这就涉及到C++多态情况下的实现机制，详细内容可参考其他书籍等资料。这里简单说一下就是虚函数表起始地址之上保存了一个type_info类对象，type_info对象里保存了此类的全限定名等信息。因此typeid()方法接受一个基类指针指向的子类对象时，如果是判断此指针，则是静态判断，依然输出的是P1X这种，表明这是一个指针，指向X类型。只有用指针的解引用输入到typeid()中才能输出指针指向的对象的真实类型。 ​ 说道这里基本了解了RTTI的实现原理以及应用，但是我们写代码时候一般在有多态情况下不用typeid来做判断，因为它无法处理例子1中的继承关系，如果没有虚函数，typeid就只能做静态推到，而C++又允许没有虚函数的继承层次。为了灵活的处理，建议使用dynamic_cast,它正确的返回结果是子类的地址，错误的返回是null，例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;typeinfo&gt;using namesapce std;class X&#123; public: X() &#123; mX = 101; &#125; virtual ~X() &#123; &#125; private: int mX;&#125;; class XX : public X&#123; public: XX(): X() &#123; mXX = 1001; &#125; virtual ~XX() &#123; &#125; private: int mXX;&#125;; class YX : public X&#123; public: YX() &#123; mYX = 1002; &#125; virtual ~YX() &#123; &#125; private: int mYX;&#125;;int main()&#123; X x; XX xx; YX yx; X *px = &amp;xx; cout &lt;&lt; px &lt;&lt; endl; XX *pxx = dynamic_cast&lt;XX*&gt;(px); // 转换1 cout &lt;&lt; pxx &lt;&lt; endl; YX *pyx = dynamic_cast&lt;YX*&gt;(px); // 转换2 cout &lt;&lt; pyx &lt;&lt; endl; pyx = (YX*)px; // 转换3 cout &lt;&lt; pyx &lt;&lt; endl; pyx = static_cast&lt;YX*&gt;(px); // 转换4 cout &lt;&lt; pyx &lt;&lt; endl; return 0;&#125; ​ 只有转换1是成功的，转换2输出null,转换3是C风格的转换，看似成功，但是一旦发生调用，就出错，转换4是强制转换，看似成功，但是一旦发生调用就出错。上述例子是以指针作为案例，如果是引用呢？对于引用，dynamic_cast的错误输出的抛出一个bad cast异常。比如如果要判断上述代码中px指向的对象是否是X类的子类。则： 1if(dynamic_cast&lt;X*&gt;(px)) cout&lt;&lt;"px pointer is sub class of X"&lt;&lt;endl; ​ 最后补充一些dynamic_cast的实现原理： ​ 1）计算指针或引用变量所指的对象的虚函数表的type_info信息，如下：(type_info*)px-&gt;vptr[-1] ​ 2）静态推导向下转型的目标类型的type_info信息，即获取类XX的type_info信息 ​ 3）比较1）和2）中获取到的type_info信息，若2）中的类型信息与1）中的类型信息相等或是其基类类型，则返回相应的对象或子对象的地址，否则返回NULL。 ​ dynamic_cast不是常量时间的操作，不建议过多使用，其底层原理基本typeid都可以搞定。所以建议多使用typeid而非dynamic_cast操作。 ####]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包的理解]]></title>
    <url>%2F2018%2F10%2F20%2F%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[闭包，这是函数式编程的一个典型用法，很多人对其定义深感困惑，即便看懂例子，让其给别人介绍什么是闭包，他依然无法清晰准确的回答出什么是闭包。其实闭包很简单，之所以让人感到困惑，是因为大家不知道闭包底层是如何实现的，一旦大家理解如何实现闭包，则问题迎刃而解。首先我们看一下Golang的一个闭包例子： 12345678910111213141516package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int&#123; num++ return num &#125;&#125;func main() &#123; rtFunc := clourse(2) fmt.Println(rtFunc()) //3 fmt.Println(rtFunc()) //4&#125; 再看如下调用后所得结果： 1234567891011121314151617181920package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int &#123; num++ return num &#125;&#125;func main() &#123; rtFuncOne := clourse(2) rtFruncTwo := clourse(7) fmt.Println(rtFuncOne()) //答案 3 fmt.Println(rtFuncOne()) //答案 4 fmt.Println(rtFuncTwo()) //答案 8 fmt.Println(rtFuncTwo()) //答案 9&#125; 如果能够快速回答出上述代码的输出，并理解原因，则无需阅读下面的内容。如果还是不太理解答案，则下文将带你彻底弄懂闭包。 闭包的定义较为晦涩，我个人的理解是调用一个函数A，这个A函数返回一个函数B，返回的函数B中还包括了函数A的上下文环境。这样描述还是比较难以理解。在先讲闭包前，看一个行为和闭包一样的代码例子： 123456789101112131415161718package mainimport "fmt"type clourse struct &#123; num int&#125;func (cs *clourse) add() int &#123; cs.num++ return cs.num&#125;func main() &#123; test := clourse&#123;2&#125; fmt.Println(test.add()) //答案 3 fmt.Println(test.add()) //答案 4&#125; 如果看到这里，你恍然大悟了，那么你便懂了什么是闭包，如果还是没懂，没关系。我来讲解一下闭包的底层实现。 在第一个闭包的例子中，你可以这样理解，函数clourse返回的不是一个函数，而是一个结构 ,这个结构包含一个上下文num,还包括一个自增函数 ，自增函数每次都是在num的基础上进行过程调用。上述闭包达到的效果就是和第三个小例子一样，而实际上，golang在底层也是如此实现的。看到这里，你如果深入理解闭包的返回值，其实这不就是对应java中的class吗？一个class,封装了数据和对数据的操作，并且这份数据只属于此class，多次调用一个class的实例，将带来多次副作用。进一步的，其实在C语言中在Struct中包含一个上下文，一个函数指针，也能实现上述效果，其实上述结构描述的都是一种封装概念，将数据和对数据的操作封装起来供开发者调用。只不过在函数式编程里面，为了达到上述效果，发明了一个闭包的概念。殊途而同归，深入理解这些概念，你会发现编程语言特性才是最重要的，如果不能深入理解编程语言特性，不管你学多少种编程语言，还是不能达到融会贯通的地步。]]></content>
      <categories>
        <category>Function Programming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Home]]></title>
    <url>%2F2018%2F10%2F16%2FHome%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到我的博客，此博客是为了记录个人学习，生活中的一些随笔，如有帮助，欢迎点击文章底部的打赏按钮，比心。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Go语言的值语义与引用语义]]></title>
    <url>%2F2018%2F10%2F16%2FGo%E8%AF%AD%E8%A8%80%E7%9A%84%E5%80%BC%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[​ 任何一门语言，如果其有指针概念，则需要了解这门语言是否拥有引用语义，当然你可以说任何引用语义都是值语义（正确的废话）。之所以这个内容需要深入理解，因为它涉及到一个重要的内容，那就是比较 ，编程语言的三大结构，都需要依赖比较功能，而比较就需要我们理解比较的到底是变量的值，还是变量指向的值。 12345func main()&#123; a := "yichen" b := "yichen" fmt.Print(a == b) //true 可以看出string是值语义&#125; 123456func main()&#123; a := [3]&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,2,3&#125;,&#123;1,3,3&#125; 可以看出数组居然也是值语义&#125; 123456func main()&#123; a := []&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,3,3&#125;,&#123;1,3,3&#125; 可以看出slice是引用语义&#125; 12345678910type Person struct&#123; age int name string&#125;func main() &#123; yichen := Person&#123;21,"yichen"&#125; pengfan := Person&#123;21,"yichen"&#125; fmt.Println(yichen == pengfan) //true 不可思议的是struct也是值语义&#125; 1234567891011type Person struct&#123; age int name string&#125;func main() &#123; a := Person&#123;21,"yichen"&#125; b := &amp;a c := &amp;a fmt.Println(b == c) //true 指针也是值语义&#125; 总结值语义基本类型，如byte、int、bool、float32、float64和string等;复合类型，如数组(array)、结构体(struct)和指针(pointer)等。 引用语义slice,map,list,heap,ring,channels]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
