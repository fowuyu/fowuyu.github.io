<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 析构函数与delete的区别于联系]]></title>
    <url>%2F2019%2F01%2F07%2FC%2B%2B%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8Edelete%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[​ delete必须和new成对出现，delete一个指针可以视为两件事：1.调用析构函数；2.free指针所指向对象的内存空间。 ​ 即便一个类或者struct没有析构函数，delete依然可以正确释放类对象所用内存空间，但是不能正确释放类持有的其他文件句柄或者系统资源。 ​ delete调用析构函数是充分非必要操作！！！]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点数的二进制表示]]></title>
    <url>%2F2019%2F01%2F04%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[首先看一道题： 12345678910#include &lt;stdio.h&gt;void main(void)&#123; int num=9; /* num是整型变量，设为9 */ float* pFloat=&amp;num; /* pFloat表示num的内存地址，但是设为浮点数 */ printf("num的值为：%d\n",num); /* 显示num的整型值 */ printf("*pFloat的值为：%f\n",*pFloat); /* 显示num的浮点值 */ *pFloat=9.0; /* 将num的值改为浮点数 */ printf("num的值为：%d\n",num); /* 显示num的整型值 */ printf("*pFloat的值为：%f\n",*pFloat); /* 显示num的浮点值 */&#125; 结果如下： 1234num的值为：9*pFloat的值为：0.000000num的值为：1091567616*pFloat的值为：9.000000 在讨论浮点数之前，先看一下整数在计算机内部是怎样表示的。 int num=9; 上面这条命令，声明了一个整数变量，类型为int，值为9（二进制写法为1001）。普通的32位计算机，用4个字节表示int变量，所以9就被保存为00000000 00000000 00000000 00001001，写成16进制就是0x00000009。 那么，我们的问题就简化成：为什么0x00000009还原成浮点数，就成了0.000000? 根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式： $$V = (-1)^8 M 2^E$$ （1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 （2）M表示有效数字，大于等于1，小于2。 ​ （3）2^E表示指数位。 举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。 十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。 IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。 对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。 IEEE 754对有效数字M和指数E，还有一些特别规定。 ​ 前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。 至于指数E，情况就比较复杂。首先，E为一个无符号整数（unsigned int）。这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。 比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。 然后，指数E还可以再分成三种情况： （1）E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。 （2）E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。 （3）E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。 回顾好了，关于浮点数的表示规则，就说到这里。 下面，让我们回到一开始的问题：为什么0x00000009还原成浮点数，就成了0.000000？ 首先，将0x00000009拆分，得到第一位符号位s=0，后面8位的指数E=00000000，最后23位的有效数字M=000 0000 0000 0000 0000 1001。 由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成： V=(-1)^0×0.00000000000000000001001×2^(-126)=1.001×2^(-146) 显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000。 再看例题的第二部分。 请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？ 首先，浮点数9.0等于二进制的1001.0，即1.001×2^3。 那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010。 所以，写成二进制形式，应该是s+E+M，即0 10000010 001 0000 0000 0000 0000 0000。这个32位的二进制数，还原成十进制，正是1091567616。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包的理解]]></title>
    <url>%2F2018%2F10%2F20%2F%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[闭包，这是函数式编程的一个典型用法，很多人对其定义深感困惑，即便看懂例子，让其给别人介绍什么是闭包，他依然无法清晰准确的回答出什么是闭包。其实闭包很简单，之所以让人感到困惑，是因为大家不知道闭包底层是如何实现的，一旦大家理解如何实现闭包，则问题迎刃而解。首先我们看一下Golang的一个闭包例子： 12345678910111213141516package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int&#123; num++ return num &#125;&#125;func main() &#123; rtFunc := clourse(2) fmt.Println(rtFunc()) //3 fmt.Println(rtFunc()) //4&#125; 再看如下调用后所得结果： 1234567891011121314151617181920package mainimport ( "fmt")func clourse(num int) func() int &#123; return func() int &#123; num++ return num &#125;&#125;func main() &#123; rtFuncOne := clourse(2) rtFruncTwo := clourse(7) fmt.Println(rtFuncOne()) //答案 3 fmt.Println(rtFuncOne()) //答案 4 fmt.Println(rtFuncTwo()) //答案 8 fmt.Println(rtFuncTwo()) //答案 9&#125; 如果能够快速回答出上述代码的输出，并理解原因，则无需阅读下面的内容。如果还是不太理解答案，则下文将带你彻底弄懂闭包。 闭包的定义较为晦涩，我个人的理解是调用一个函数A，这个A函数返回一个函数B，返回的函数B中还包括了函数A的上下文环境。这样描述还是比较难以理解。在先讲闭包前，看一个行为和闭包一样的代码例子： 123456789101112131415161718package mainimport "fmt"type clourse struct &#123; num int&#125;func (cs *clourse) add() int &#123; cs.num++ return cs.num&#125;func main() &#123; test := clourse&#123;2&#125; fmt.Println(test.add()) //答案 3 fmt.Println(test.add()) //答案 4&#125; 如果看到这里，你恍然大悟了，那么你便懂了什么是闭包，如果还是没懂，没关系。我来讲解一下闭包的底层实现。 在第一个闭包的例子中，你可以这样理解，函数clourse返回的不是一个函数，而是一个结构 ,这个结构包含一个上下文num,还包括一个自增函数 ，自增函数每次都是在num的基础上进行过程调用。上述闭包达到的效果就是和第三个小例子一样，而实际上，golang在底层也是如此实现的。看到这里，你如果深入理解闭包的返回值，其实这不就是对应java中的class吗？一个class,封装了数据和对数据的操作，并且这份数据只属于此class，多次调用一个class的实例，将带来多次副作用。进一步的，其实在C语言中在Struct中包含一个上下文，一个函数指针，也能实现上述效果，其实上述结构描述的都是一种封装概念，将数据和对数据的操作封装起来供开发者调用。只不过在函数式编程里面，为了达到上述效果，发明了一个闭包的概念。殊途而同归，深入理解这些概念，你会发现编程语言特性才是最重要的，如果不能深入理解编程语言特性，不管你学多少种编程语言，还是不能达到融会贯通的地步。]]></content>
      <categories>
        <category>Function Programming</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Go语言的值语义与引用语义]]></title>
    <url>%2F2018%2F10%2F16%2FGo%E8%AF%AD%E8%A8%80%E7%9A%84%E5%80%BC%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%BC%95%E7%94%A8%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[​ 任何一门语言，如果其有指针概念，则需要了解这门语言是否拥有引用语义，当然你可以说任何引用语义都是值语义（正确的废话）。之所以这个内容需要深入理解，因为它涉及到一个重要的内容，那就是比较 ，编程语言的三大结构，都需要依赖比较功能，而比较就需要我们理解比较的到底是变量的值，还是变量指向的值。 12345func main()&#123; a := "yichen" b := "yichen" fmt.Print(a == b) //true 可以看出string是值语义&#125; 123456func main()&#123; a := [3]&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,2,3&#125;,&#123;1,3,3&#125; 可以看出数组居然也是值语义&#125; 123456func main()&#123; a := []&#123;1,2,3&#125; b := a b[1]++ fmt.Print(a,b) //&#123;1,3,3&#125;,&#123;1,3,3&#125; 可以看出slice是引用语义&#125; 12345678910type Person struct&#123; age int name string&#125;func main() &#123; yichen := Person&#123;21,"yichen"&#125; pengfan := Person&#123;21,"yichen"&#125; fmt.Println(yichen == pengfan) //true 不可思议的是struct也是值语义&#125; 1234567891011type Person struct&#123; age int name string&#125;func main() &#123; a := Person&#123;21,"yichen"&#125; b := &amp;a c := &amp;a fmt.Println(b == c) //true 指针也是值语义&#125; 总结值语义基本类型，如byte、int、bool、float32、float64和string等;复合类型，如数组(array)、结构体(struct)和指针(pointer)等。 引用语义slice,map,list,heap,ring,channels]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Home]]></title>
    <url>%2F2018%2F10%2F16%2FHome%2F</url>
    <content type="text"><![CDATA[​ 欢迎来到我的博客，此博客是为了记录个人学习，生活中的一些随笔，如有帮助，欢迎点击文章底部的打赏按钮，比心。]]></content>
  </entry>
</search>
